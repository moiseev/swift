%for N in [2,3,4,8,16,32,64]:

public protocol SIMDVectorizable${N} {
  associatedtype _BuiltinVector${N}
  associatedtype _VectorMask${N}: SIMDMask, SIMDVector${N}

  static func _builtinVector${N}Initialize() -> _BuiltinVector${N}
  static func _builtinVector${N}Get(from vector: _BuiltinVector${N}, at index: Int) -> Self
  static func _builtinVector${N}Set(_ value: Self, into vector: inout _BuiltinVector${N}, at index: Int)
}

/*
public protocol SIMDIntegerVectorizable${N}:
  SIMDVectorizable${N}, FixedWidthInteger {
}

public protocol SIMDFloatingPointVectorizable${N}:
  SIMDVectorizable${N}, BinaryFloatingPoint {
}
*/

/// A computational vector with ${N} elements.
public protocol SIMDVector${N} : SIMDVector where Mask : SIMDVector${N} {
% if N >= 4:
  /// A type representing half of the vector.
  associatedtype HalfVector: SIMDVector${N/2} where HalfVector.Element == Element

  init(lowHalf: HalfVector, highHalf: HalfVector)

  var lowHalf: HalfVector { get set }

  var highHalf: HalfVector { get set }

  var evenHalf: HalfVector { get set }

  var oddHalf: HalfVector { get set }
% end
}

//  Non-customizable operations on SIMDVector${N}
public extension SIMDVector${N} {

  @_transparent
  var count: Int { return ${N} }

  @inlinable
  init(${', '.join(['_ v' + str(n) + ': Element' for n in range(N)])}) {
    self.init()
% for n in range(N):
    self[${n}] = v${n}
% end
  }

% if N <= 4:
  @inlinable
  init(${', '.join([c + ': Element' for c in 'xyzw'[:N]])}) {
    self.init(${', '.join('xyzw'[:N])})
  }

%  for n in range(N):
  @_transparent
  var ${'xyzw'[n]}: Element {
    @_transparent get { return self[${n}]}
    @_transparent set { self[${n}] = newValue }
  }

%  end
% end
  @inlinable
  init<D, I>(gathering source: D, at index: I)
  where D : SIMDVector, D.Element == Element,
        I : SIMDIntegerVector & SIMDVector${N} {
    self.init()
    for i in 0 ..< count {
      if index[i] >= 0 && index[i] < source.count {
        self[i] = source[Int(index[i])]
      }
    }
  }
}

//  Defaulted conformance to SIMDVector.
public extension SIMDVector${N} {
  @inlinable
  init(repeating x: Element) {
    self.init(${', '.join('x'*N)})
  }

  @inlinable
  init(arrayLiteral elements: Element...) {
    self.init(elements)
  }

  @inlinable
  init(_ array: [Element]) {
    _precondition(array.count == ${N})
    self.init()
    for i in 0 ..< count { self[i] = array[i] }
  }
}
% if N >= 4:

//  Defaulted conformance to SIMDVectorN, providing the half-vector accessors.
public extension SIMDVector${N} {
  @_transparent
  init(lowHalf: HalfVector, highHalf: HalfVector) {
    self.init()
    self.lowHalf = lowHalf
    self.highHalf = highHalf
  }

  // Implementing these via for-loop looks inefficient, but the optimizer
  // is generally pretty good at recognizing the idiom and mapping this to
  // a single shuffle-vector operation. For any outstanding cases we find,
  // we can either work on the optimizer, specialize for the types where the
  // codegen is bad, or add a header-inline C shim that just wraps the
  // shufflevector operation that we want to generate if necessary.
%  for (half,indx) in [('low','i'), ('high',str(N/2)+'+i'), ('even','2*i'), ('odd','2*i+1')]:
  var ${half}Half: HalfVector {
    @inlinable
    get {
      var result = HalfVector()
      for i in 0 ..< result.count { result[i] = self[${indx}] }
      return result
    }

    @inlinable
    set {
      for i in 0 ..< newValue.count { self[${indx}] = newValue[i] }
    }
  }
%  end
}

% end

extension SIMD {

  @_fixed_layout
  public struct Vector${N}<Element>
  where Element : SIMDVectorizable${N} & Hashable {
    public var _value: Element._BuiltinVector${N}
    // FIXME: marking it @_transparent results in a compiler error
    public init(_ _value: Element._BuiltinVector${N}) {
      self._value = _value
    }
  }
}

extension SIMD.Vector${N} /*: SIMDVector*/ {
  public typealias Mask = Element._VectorMask${N}

  @_transparent
  public init() {
    self.init(Element._builtinVector${N}Initialize())
  }

  public subscript(index: Int) -> Element {
    @_transparent
    get {
      // FIXME: make sure that these preconditions are checked
      // _precondition(index >= 0 && index < ${N})
      return Element._builtinVector${N}Get(from: _value, at: index)
    }

    @_transparent
    set {
      // _precondition(index >= 0 && index < ${N})
      Element._builtinVector${N}Set(newValue, into: &_value, at: index)
    }
  }
}

// FIXME: Next do this!!!
extension SIMD.Vector${N}/*: SIMDVector${N} */ {
% if N >= 4:
  public typealias HalfVector = SIMD.Vector${N/2}
% end
}

%end
