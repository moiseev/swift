%for N in [2,3,4,8,16,32,64]:

public protocol SIMDVectorizable${N} {
  associatedtype _BuiltinVector${N}
  associatedtype _Vector${N}Mask: SIMDMask, SIMDVector${N}

  // Hooks for the SIMDVector conformance
  static func _builtinVector${N}Initialize() -> _BuiltinVector${N}
  static func _builtinVector${N}Get(from vector: _BuiltinVector${N}, at index: Int) -> Self
  static func _builtinVector${N}Set(_ value: Self, into vector: inout _BuiltinVector${N}, at index: Int)
  static func _builtinVector${N}(_ lhs: _BuiltinVector${N}, isEqualTo rhs: _BuiltinVector${N}) -> _Vector${N}Mask
  static func _builtinVector${N}(_ value: _BuiltinVector${N}, replacingWith other: _BuiltinVector${N}, where mask: _Vector${N}Mask) -> _BuiltinVector${N}
}

public protocol SIMDIntegerVectorizable${N}:
  SIMDVectorizable${N}, FixedWidthInteger {
  static func _builtinVector${N}Initialize(bitMaskFrom: _Vector${N}Mask) -> _BuiltinVector${N}
  static func _builtinVector${N}LeadingZeroBitCount(in vector: _BuiltinVector${N}) -> _BuiltinVector${N}
  static func _builtinVector${N}TrailingZeroBitCount(in vector: _BuiltinVector${N}) -> _BuiltinVector${N}
  static func _builtinVector${N}NonzeroBitCount(in vector: _BuiltinVector${N}) -> _BuiltinVector${N}
  static func _builtinVector${N}ElementBytesSwapped(in vector: _BuiltinVector${N}) -> _BuiltinVector${N}

  static func _builtinVector${N}(_ lhs: _BuiltinVector${N}, isLessThan rhs: _BuiltinVector${N}) -> _Vector${N}Mask
  static func _builtinVector${N}(_ lhs: _BuiltinVector${N}, isLessThanOrEqualTo rhs: _BuiltinVector${N}) -> _Vector${N}Mask
  static func _builtinVector${N}(_ lhs: _BuiltinVector${N}, isGreaterThan rhs: _BuiltinVector${N}) -> _Vector${N}Mask
  static func _builtinVector${N}(_ lhs: _BuiltinVector${N}, isGreaterThanOrEqualTo rhs: _BuiltinVector${N}) -> _Vector${N}Mask

  static func _builtinVector${N}Complement(of vector: _BuiltinVector${N}) -> _BuiltinVector${N}
  static func _builtinVector${N}(_ lhs: _BuiltinVector${N}, xor rhs: _BuiltinVector${N}) -> _BuiltinVector${N}
  static func _builtinVector${N}(_ lhs: _BuiltinVector${N}, and rhs: _BuiltinVector${N}) -> _BuiltinVector${N}
  static func _builtinVector${N}(_ lhs: _BuiltinVector${N}, or rhs: _BuiltinVector${N}) -> _BuiltinVector${N}
  static func _builtinVector${N}(_ lhs: _BuiltinVector${N}, shiftedRightBy rhs: _BuiltinVector${N}) -> _BuiltinVector${N}
  static func _builtinVector${N}(_ lhs: _BuiltinVector${N}, shiftedLeftBy rhs: _BuiltinVector${N}) -> _BuiltinVector${N}
  static func _builtinVector${N}(_ lhs: _BuiltinVector${N}, adding rhs: _BuiltinVector${N}) -> _BuiltinVector${N}
  static func _builtinVector${N}(_ lhs: _BuiltinVector${N}, subtracting rhs: _BuiltinVector${N}) -> _BuiltinVector${N}
  static func _builtinVector${N}(_ lhs: _BuiltinVector${N}, multipliedBy rhs: _BuiltinVector${N}) -> _BuiltinVector${N}
  static func _builtinVector${N}(_ lhs: _BuiltinVector${N}, dividedBy rhs: _BuiltinVector${N}) -> _BuiltinVector${N}
  static func _builtinVector${N}(_ lhs: _BuiltinVector${N}, remainderDividingBy rhs: _BuiltinVector${N}) -> _BuiltinVector${N}
}

public protocol SIMDFloatingPointVectorizable${N}:
  SIMDVectorizable${N}, BinaryFloatingPoint {
}

/// A computational vector with ${N} elements.
public protocol SIMDVector${N} : SIMDVector where Mask : SIMDVector${N} {
% if N >= 4:
  /// A type representing half of the vector.
  associatedtype HalfVector: SIMDVector${N/2} where HalfVector.Element == Element

  init(lowHalf: HalfVector, highHalf: HalfVector)

  var lowHalf: HalfVector { get set }

  var highHalf: HalfVector { get set }

  var evenHalf: HalfVector { get set }

  var oddHalf: HalfVector { get set }
% end
}

//  Non-customizable operations on SIMDVector${N}
public extension SIMDVector${N} {

  @_transparent
  var count: Int { return ${N} }

  @inlinable
  init(${', '.join(['_ v' + str(n) + ': Element' for n in range(N)])}) {
    self.init()
% for n in range(N):
    self[${n}] = v${n}
% end
  }

% if N <= 4:
  @inlinable
  init(${', '.join([c + ': Element' for c in 'xyzw'[:N]])}) {
    self.init(${', '.join('xyzw'[:N])})
  }

%  for n in range(N):
  @_transparent
  var ${'xyzw'[n]}: Element {
    @_transparent get { return self[${n}]}
    @_transparent set { self[${n}] = newValue }
  }

%  end
% end
  @inlinable
  init<D, I>(gathering source: D, at index: I)
  where D : SIMDVector, D.Element == Element,
        I : SIMDIntegerVector & SIMDVector${N} {
    self.init()
    for i in 0 ..< count {
      if index[i] >= 0 && index[i] < source.count {
        self[i] = source[Int(index[i])]
      }
    }
  }
}

//  Defaulted conformance to SIMDVector.
public extension SIMDVector${N} {
  @inlinable
  init(repeating x: Element) {
    self.init(${', '.join('x'*N)})
  }

  @inlinable
  init(arrayLiteral elements: Element...) {
    self.init(elements)
  }

  @inlinable
  init(_ array: [Element]) {
    _precondition(array.count == ${N})
    self.init()
    for i in 0 ..< count { self[i] = array[i] }
  }
}
% if N >= 4:

//  Defaulted conformance to SIMDVectorN, providing the half-vector accessors.
public extension SIMDVector${N} {
  @_transparent
  init(lowHalf: HalfVector, highHalf: HalfVector) {
    self.init()
    self.lowHalf = lowHalf
    self.highHalf = highHalf
  }

  // Implementing these via for-loop looks inefficient, but the optimizer
  // is generally pretty good at recognizing the idiom and mapping this to
  // a single shuffle-vector operation. For any outstanding cases we find,
  // we can either work on the optimizer, specialize for the types where the
  // codegen is bad, or add a header-inline C shim that just wraps the
  // shufflevector operation that we want to generate if necessary.
%  for (half,indx) in [('low','i'), ('high',str(N/2)+'+i'), ('even','2*i'), ('odd','2*i+1')]:
  var ${half}Half: HalfVector {
    @inlinable
    get {
      var result = HalfVector()
      for i in 0 ..< result.count { result[i] = self[${indx}] }
      return result
    }

    @inlinable
    set {
      for i in 0 ..< newValue.count { self[${indx}] = newValue[i] }
    }
  }
%  end
}

% end

extension SIMD {

  @_fixed_layout
  public struct Vector${N}<Element>
  where Element: Hashable & SIMDVectorizable${N} {
    public var _value: Element._BuiltinVector${N}

    // FIXME: marking it @_transparent results in a compiler error
    public init(_ _value: Element._BuiltinVector${N}) {
      self._value = _value
    }
  }
}

extension SIMD.Vector${N}: SIMDVector {
  public typealias Mask = Element._Vector${N}Mask

  @_transparent
  public init() {
    self.init(Element._builtinVector${N}Initialize())
  }

  public subscript(index: Int) -> Element {
    @_transparent
    get {
      // FIXME: make sure that these preconditions are checked
      // _precondition(index >= 0 && index < ${N})
      return Element._builtinVector${N}Get(from: _value, at: index)
    }

    @_transparent
    set {
      // _precondition(index >= 0 && index < ${N})
      Element._builtinVector${N}Set(newValue, into: &_value, at: index)
    }
  }

  public static func .==(
    lhs: SIMD.Vector${N}<Element>, rhs: SIMD.Vector${N}<Element>
  ) -> Mask {
    return Element._builtinVector${N}(lhs._value, isEqualTo: rhs._value)
  }

  public func replacing(
    with other: SIMD.Vector${N}<Element>, where mask: Mask
  ) -> SIMD.Vector${N}<Element> {
    return SIMD.Vector${N}(
      Element._builtinVector${N}(_value, replacingWith: other._value, where: mask))
  }

  // FIXME: this part of SIMDVector conformance could be provided by
  // SIMDVector${N} defaults, but SIMD.Vector${N} only conforms to
  // SIMDVector${N} conditionally, so...
  @_transparent
  public var count: Int { return ${N} }

  @inlinable
  public init(repeating x: Element) {
    self = [${', '.join('x'*N)}]
  }

  @inlinable
  public init(arrayLiteral elements: Element...) {
    self.init(elements)
  }

  @inlinable
  public init(_ array: [Element]) {
    _precondition(array.count == ${N})
    self.init()
    for i in 0 ..< count { self[i] = array[i] }
  }
}

%{
# In order to conform to SIMDVectorN, the HalfVector type with the same Element
# type is needed, # which means that the same Element now needs to not only
# conform to SIMDVectorizableN, # but also SIMDVectorizable(N/2), adn so forth
# recursively all the way down to SIMDVectorizable2.
Constraints = ''
if N >= 4:
  SubNs = [n for n in [2,4,8,16,32] if n < N]
  Constraints = '\nwhere Element: ' + ' & '.join(['SIMDVectorizable' + str(n) for n in SubNs])
}%
extension SIMD.Vector${N}: SIMDVector${N} ${Constraints} {
% if N >= 4:
  public typealias HalfVector = SIMD.Vector${N/2}<Element>
% end
}

extension SIMD.Vector${N}: SIMDIntegerVector
where Element: SIMDIntegerVectorizable${N} & FixedWidthInteger {

  @inlinable
  public init(bitMaskFrom mask: Mask) {
    self.init(Element._builtinVector${N}Initialize(bitMaskFrom: mask))
  }

%   firstCap = lambda s: s[:1].upper() + s[1:]
%   for property in [
%     'leadingZeroBitCount',
%     'trailingZeroBitCount',
%     'nonzeroBitCount',
%     'elementBytesSwapped']:
  public var ${property}: SIMD.Vector${N}<Element> {
    return SIMD.Vector${N}(
      Element._builtinVector${N}${firstCap(property)}(in: _value))
  }
%   end


%   for (operator, spelling) in [
%      ('<', 'isLessThan'),
%      ('<=', 'isLessThanOrEqualTo'),
%      ('>', 'isGreaterThan'),
%      ('>=', 'isGreaterThanOrEqualTo')
%   ]:
  public static func ${operator}(
    lhs: SIMD.Vector${N}<Element>, rhs: SIMD.Vector${N}<Element>
  ) -> Mask {
    return Element._builtinVector${N}(lhs._value, ${spelling}: rhs._value)
  }
%   end


  public static prefix func ~(
    rhs: SIMD.Vector${N}<Element>
  ) -> SIMD.Vector${N}<Element> {
    return SIMD.Vector${N}(
      Element._builtinVector${N}Complement(of: rhs._value))
  }

%   for (operator, spelling) in [
%      ('^', 'xor'),
%      ('&', 'and'),
%      ('|', 'or'),
%      ('&>>', 'shiftedRightBy'),
%      ('&<<', 'shiftedLeftBy'),
%      ('&+', 'adding'),
%      ('&-', 'subtracting'),
%      ('.&*', 'multipliedBy'),
%      ('/', 'dividedBy'),
%      ('%', 'remainderDividingBy')
%   ]:
  public static func ${operator}(
    lhs: SIMD.Vector${N}<Element>, rhs: SIMD.Vector${N}<Element>
  ) -> SIMD.Vector${N}<Element> {
    return SIMD.Vector${N}(
      Element._builtinVector${N}(lhs._value, ${spelling}: rhs._value))
  }
%   end

}
%end
