%{
eltsizes = [32, 64]
fltnames = {32:'Float', 64:'Double'}
counts = [2,3,4,8,16]
def llvmFloatVec(bits, count):
  return 'Vec' + str(count) + 'xFPIEEE' + str(bits)
}%

%for bits in eltsizes:
% Element = fltnames[bits]
public extension ${Element} {
% for N in counts:
%  # In theory, LLVM should handle padding 3-element vectors out to 4-element
%  # for us. And it does, but we end up triggering asserts for some operations,
%  # so it ends up being simpler to pad at the Swift level instead.
%  llvmN = N if N != 3 else 4
%  if bits*llvmN <= 512:
%   LLVM = llvmFloatVec(bits, llvmN)
%   Self = 'Vector' + str(N)
%   BitPattern = 'Int' + str(bits) + '.Vector' + str(N)
%   BitPatternLLVM = 'Vec' + str(llvmN) + 'xInt' + str(bits)
  @_fixed_layout
  struct ${Self} : SIMDFloatingPointVector, SIMDVector${N} {

    public var _value: Builtin.${LLVM}

    @_transparent
    public init(_ _value: Builtin.${LLVM}) {
      self._value = _value
    }

    // Conformance to SIMDVector ---------------------------------------------
    @_transparent
    public init( ) {
      self._value = Builtin.zeroInitializer()
    }

    public subscript(index: Int) -> ${Element} {
      @_transparent
      get {
        _precondition(index >= 0 && index < ${N})
        return ${Element}(Builtin.extractelement_${LLVM}_Int32(
          _value, Int32(index)._value
        ))
      }
      @_transparent
      set {
        _precondition(index >= 0 && index < ${N})
        _value = Builtin.insertelement_${LLVM}_FPIEEE${bits}_Int32(
          _value, newValue._value, Int32(index)._value
        )
      }
    }

    public typealias Mask = SIMD.Mask${bits}.Vector${N}

%   sext = 'Builtin.sext_Vec' + str(llvmN) + 'xInt1_' + BitPatternLLVM
    @_transparent
    public static func .==(lhs: ${Self}, rhs: ${Self}) -> Mask {
      return Mask(Int${bits}.Vector${N}(${sext}(
        Builtin.fcmp_oeq_${LLVM}(lhs._value, rhs._value))))
    }

    @_transparent
    public init(bitPattern other: Int${bits}.Vector${N}) {
      _value = Builtin.bitcast_${BitPatternLLVM}_${LLVM}(other._value)
    }

    @_transparent
    public init(bitPattern other: UInt${bits}.Vector${N}) {
      _value = Builtin.bitcast_${BitPatternLLVM}_${LLVM}(other._value)
    }

    @_transparent
    public func replacing(with other: ${Self}, where mask: Mask) -> ${Self} {
      return ${Self}(bitPattern: ${BitPattern}(bitPattern: self).replacing(
        with: ${BitPattern}(bitPattern: other), where: mask
      ))
    }

    // Conformance to SIMDVector${N} -----------------------------------------
%   if N >= 4:
    public typealias HalfVector = Vector${N/2}
%   end

%   Index = 'Int' + str(bits) + '.' + Self
    @inlinable
    public init<D>(gathering source: D, at index: ${Index})
    where D : SIMDVector, D.Element == Element {
      self.init()
      for i in 0 ..< count {
        if index[i] >= 0 && index[i] < source.count {
          self[i] = source[Int(index[i])]
        }
      }
    }

    // Conformance to SIMDFloatingPointVector --------------------------------
%   for (op, inst) in [('<','lt'), ('<=','le'), ('>','gt'), ('>=','ge')]:
    @_transparent
    public static func ${op}(lhs: ${Self}, rhs: ${Self}) -> Mask {
      return Mask(Int${bits}.Vector${N}(${sext}(
        Builtin.fcmp_o${inst}_${LLVM}(lhs._value, rhs._value)
      )))
    }

%   end
    // MARK: Arithmetic operators
%   for (op, inst) in [('+','add'), ('-','sub'), ('.*','mul'), ('/','div')]:
    @_transparent
    public static func ${op}(lhs: ${Self}, rhs: ${Self}) -> ${Self} {
      return ${Self}(Builtin.f${inst}_${LLVM}(lhs._value, rhs._value))
    }

%   end
    @_transparent
    public func addingProduct(_ lhs: ${Self}, _ rhs: ${Self}) -> ${Self} {
      return ${Self}(Builtin.int_fma_${LLVM}(lhs._value, rhs._value, _value))
    }

    @_transparent
    public mutating func round(_ rule: FloatingPointRoundingRule) {
      switch rule {
      case .toNearestOrAwayFromZero:
        _value = Builtin.int_round_${LLVM}(_value)
      case .toNearestOrEven:
        _value = Builtin.int_rint_${LLVM}(_value)
      case .towardZero:
        _value = Builtin.int_trunc_${LLVM}(_value)
      case .awayFromZero:
        let roundedUp = ${Self}(Builtin.int_ceil_${LLVM}(_value))
        let roundedDown = ${Self}(Builtin.int_floor_${LLVM}(_value))
        self = roundedUp.replacing(with: roundedDown, where: self < 0)
      case .up:
        _value = Builtin.int_ceil_${LLVM}(_value)
      case .down:
        _value = Builtin.int_floor_${LLVM}(_value)
      @unknown default:
        self._roundSlowPath(rule)
      }
    }

    // Slow path for new cases that might have been inlined into an old
    // ABI-stable version of round(_:) called from a newer version. If this is
    // the case, this non-inlinable function will call into the _newer_ version
    // which _will_ support this rounding rule.
    @usableFromInline
    internal mutating func _roundSlowPath(_ rule: FloatingPointRoundingRule) {
      self.round(rule)
    }

    // Conversion from other floating-point vectors.
%   for otherBits in eltsizes:
%    if otherBits != bits and otherBits*llvmN <= 512:
%     OtherElement = {32:'Float', 64:'Double'}[otherBits]
    @_transparent
    public init(_ other: ${OtherElement}.Vector${N}) {
%     if otherBits > bits:
      _value = Builtin.fptrunc_${llvmFloatVec(otherBits, llvmN)}_${LLVM}(other._value)
%     else:
      _value = Builtin.fpext_${llvmFloatVec(otherBits, llvmN)}_${LLVM}(other._value)
%     end
    }
%    end
%   end

    // Conversion from integer vectors.
%   for otherBits in [8,16,32,64]:
%    if otherBits*llvmN <= 512:
    @_transparent
    public init(_ other: Int${otherBits}.Vector${N}) {
      _value = Builtin.sitofp_Vec${llvmN}xInt${otherBits}_${LLVM}(other._value)
    }

    @_transparent
    public init(_ other: UInt${otherBits}.Vector${N}) {
      _value = Builtin.uitofp_Vec${llvmN}xInt${otherBits}_${LLVM}(other._value)
    }
%    end
%   end
  }

%  end
% end
}

%end
