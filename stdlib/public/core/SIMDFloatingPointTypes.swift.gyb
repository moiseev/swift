/*
%{
eltsizes = [32,64]
counts = [2,3,4,8,16]
}%

%for bits in eltsizes:
%  Element = {32:'Float', 64:'Double'}[bits]
public extension ${Element} {
%  for N in counts:
%   # In theory, LLVM should handle padding 3-element vectors out to 4-element
%   # for us. And it does, but we end up triggering asserts for some operations,
%   # so it seems simpler to just handle this padding at the Swift level.
%   llvmN = N if N != 3 else 4
%   if bits*llvmN <= 512:
%    LLVM = 'Vec' + str(llvmN) + 'xFPIEEE' + str(bits)
%    LLVMInt = 'Vec' + str(llvmN) + 'xInt' + str(bits)
%    Self = 'Vector' + str(N)
  @_fixed_layout
  public struct Vector${N} : SIMDFloatingPointVector, SIMDVector${N} {

    public var _value: Builtin.${LLVM}

    @_transparent
    public init( ) {
      self._value = Builtin.zeroInitializer()
    }

    @_transparent
    public init(_ _value: Builtin.${LLVM}) {
      self._value = _value
    }

    public subscript(index: Int) -> ${Element} {
      @_transparent
      get {
        _precondition(index >= 0 && index < ${N})
        return ${Element}(Builtin.extractelement_${LLVM}_Int32(
          _value, Int32(index)._value
        ))
      }
      @_transparent
      set {
        _precondition(index >= 0 && index < ${N})
        _value = Builtin.insertelement_${LLVM}_FPIEEE${bits}_Int32(
          _value, newValue._value, Int32(index)._value
        )
      }
    }

    // MARK: Comparison operators
    public typealias Predicate = SIMDPredicate${bits}x${N}

%{
sextI1 = 'Builtin.sext_Vec' + str(llvmN) + 'xInt1_' + LLVMInt
cmps = [('==','oeq'), ('!=','une'),
        ('<','olt'), ('<=','ole'), ('>','ogt'), ('>=','oge')]
}%
%    for (op, inst) in cmps:
    @_transparent
    public static func ${op}(lhs: ${Self}, rhs: ${Self}) -> Predicate {
      return Predicate(${sextI1}(Builtin.fcmp_${inst}_${LLVM}(lhs._value, rhs._value)))
    }

%    end

    // MARK: Arithmetic operators
%    for (op, inst) in [('+','fadd'), ('-','fsub'), ('*','fmul'), ('/','fdiv')]:
    @_transparent
    public static func ${op}(lhs: ${Self}, rhs: ${Self}) -> ${Self} {
      return ${Self}(Builtin.${inst}_${LLVM}(lhs._value, rhs._value))
    }

%    end

    @_transparent
    public static prefix func -(rhs: ${Self}) -> ${Self} {
      return ${Self}(Builtin.fneg_${LLVM}(rhs._value))
    }

    @_transparent
    public static func abs(_ value: ${Self}) -> ${Self} {
      return ${Self}(Builtin.int_fabs_${LLVM}(value._value))
    }

    @inlinable
    public mutating func round(_ rule: FloatingPointRoundingRule) {
      switch rule {
      case .toNearestOrAwayFromZero:
        _value = Builtin.int_round_${LLVM}(_value)
      case .toNearestOrEven:
        _value = Builtin.int_rint_${LLVM}(_value)
      case .towardZero:
        _value = Builtin.int_trunc_${LLVM}(_value)
      case .awayFromZero:
        let down = ${Self}(Builtin.int_floor_${LLVM}(_value))
        let up =  ${Self}(Builtin.int_ceil_${LLVM}(_value))
        self = down.replacing(with: up, where: self > 0)
      case .up:
        _value = Builtin.int_ceil_${LLVM}(_value)
      case .down:
        _value = Builtin.int_floor_${LLVM}(_value)
      }
    }

    @inlinable
    public func replacing(with other: ${Self}, where predicate: Predicate) -> ${Self} {
      let intSelf = Int${bits}.Vector${N}(bitPattern: self)
      let intOther = Int${bits}.Vector${N}(bitPattern: other)
      let intResult = intSelf.replacing(with: intOther, where: predicate)
      return ${Self}(bitPattern: intResult)
    }

%    if N >= 4:
    public typealias HalfVector = Vector${N/2}

%    end
    /// A vector with the same bit pattern as `other`.
    @_transparent
    public init(bitPattern other: Int${bits}.Vector${N}) {
      self.init(Builtin.bitcast_${LLVMInt}_${LLVM}(other._value))
    }

    /// A vector with the same bit pattern as `other`.
    @_transparent
    public init(bitPattern other: UInt${bits}.Vector${N}) {
      self.init(Builtin.bitcast_${LLVMInt}_${LLVM}(other._value))
    }
  }

%   end
%  end
}

%end
*/
