%{
eltsizes = [8,16,32,64]
counts = [2,3,4,8,16,32,64]
}%

%for bits in eltsizes:
% for signed in [True, False]:
%  Element = ('' if signed else 'U') + 'Int' + str(bits)
public extension ${Element} {
%  for N in counts:
%   # In theory, LLVM should handle padding 3-element vectors out to 4-element
%   # for us. And it does, but we end up triggering asserts for some operations,
%   # so it ends up being simpler to pad at the Swift level instead.
%   llvmN = N if N != 3 else 4
%   if bits*llvmN <= 512:
%    LLVM = 'Vec' + str(llvmN) + 'xInt' + str(bits)
%    Self = 'Vector' + str(N)
  @_fixed_layout
  struct Vector${N} : SIMDIntegerVector, SIMDVector${N} {

    public var _value: Builtin.${LLVM}

    @_transparent
    public init(_ _value: Builtin.${LLVM}) {
      self._value = _value
    }

    // Conformance to SIMDVector ---------------------------------------------
    @_transparent
    public init( ) {
      self._value = Builtin.zeroInitializer()
    }

    public subscript(index: Int) -> ${Element} {
      @_transparent
      get {
        _precondition(index >= 0 && index < ${N})
        return ${Element}(Builtin.extractelement_${LLVM}_Int32(
          _value, Int32(index)._value
        ))
      }
      @_transparent
      set {
        _precondition(index >= 0 && index < ${N})
        _value = Builtin.insertelement_${LLVM}_Int${bits}_Int32(
          _value, newValue._value, Int32(index)._value
        )
      }
    }

    public typealias Predicate = SIMDPredicate${bits}x${N}

%   sext = 'Builtin.sext_Vec' + str(llvmN) + 'xInt1_' + LLVM
    @_transparent
    public static func ==(lhs: ${Self}, rhs: ${Self}) -> Predicate {
      return Predicate(Int${bits}.Vector${N}(${sext}(
        Builtin.cmp_eq_${LLVM}(lhs._value, rhs._value))))
    }

    // Conformance to SIMDVector${N} -----------------------------------------
%    if N >= 4:
    public typealias HalfVector = Vector${N/2}
%    end

    // Conformance to SIMDIntegerVector --------------------------------------
    // - Bitwise operators
%    for (op, inst) in [('&','and'), ('|','or'), ('^','xor')]:
    @_transparent
    public static func ${op}(lhs: ${Self}, rhs: ${Self}) -> ${Self} {
      return ${Self}(Builtin.${inst}_${LLVM}(lhs._value, rhs._value))
    }

%    end

%    prefix = 's' if signed else 'u'
%    for (op, inst) in [('<','lt'), ('<=','le'), ('>','gt'), ('>=','ge')]:
    @_transparent
    public static func ${op}(lhs: ${Self}, rhs: ${Self}) -> Predicate {
      return Predicate(Int${bits}.Vector${N}(${sext}(
        Builtin.cmp_${prefix}${inst}_${LLVM}(lhs._value, rhs._value)
      )))
    }

%    end

    @inlinable
    public init(bitMaskFrom predicate: Predicate) {
      self._value = predicate._value._value
    }

    // Operations not required by any protocol -------------------------------
    @inlinable
    public init<Other>(truncatingIfNeeded other: Other)
      where Other : SIMDVector${N} & SIMDIntegerVector {
      self.init()
      for i in indices { self[i] = Element(truncatingIfNeeded: other[i]) }
    }

    @inlinable
    public init<Other>(clamping other: Other) {
      // TODO: implement
      self.init()
    }

    // TODO: we shouldn't need the concrete conversions that follow; we should
    // be able to vectorize the for-loop in the generic `truncatingIfNeeded`
    // init to a single vector sext, zext, nop, or trunc (or possibly one per
    // Swift-ABI legalized result vector). However, the optimizer can't yet do
    // this for all cases, which we should fix, but as a short-term workaround
    // we also have these concrete conversions.
%    for otherBits in eltsizes:
%     if otherBits*llvmN <= 512:
%      for otherSigned in [True,False]:
%       OtherElement = ('' if otherSigned else 'U') + 'Int' + str(otherBits)
%       Other = OtherElement + '.Vector' + str(N)
%       OtherLLVM = 'Vec' + str(llvmN) + 'xInt' + str(otherBits)
    @_transparent
    public init(truncatingIfNeeded other: ${Other}) {
%       if otherBits > bits:
      self.init(Builtin.trunc_${OtherLLVM}_${LLVM}(other._value))
%       elif otherBits == bits:
      self.init(other._value)
%       elif otherSigned:
      self.init(Builtin.sext_${OtherLLVM}_${LLVM}(other._value))
%       else:
      self.init(Builtin.zext_${OtherLLVM}_${LLVM}(other._value))
%       end
    }

%      end
%     end
%    end
  }

%   end
%  end
}

% end
%end
