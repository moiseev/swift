%{
from SwiftVectorTypes import *

# Number of bits in the Builtin.Word type
word_bits = int(CMAKE_SIZEOF_VOID_P) * 8

fltnames = {32:'Float', 64:'Double'}
}%

%for element_type in all_integer_types(word_bits):
% bits = element_type.bits
% signed = element_type.is_signed
% Element = element_type.stdlib_name
public extension ${Element} {
% for vector_type in all_vector_types(element_type):
% LLVM = vector_type.builtin_name
% Self = vector_type.short_name
% count = vector_type.count
% llvmN = count if count != 3 else 4
  @_fixed_layout
  struct ${Self} : SIMDIntegerVector, SIMDVector${count} {

    public var _value: Builtin.${LLVM}

    @_transparent
    public init(_ _value: Builtin.${LLVM}) {
      self._value = _value
    }

    // Conformance to SIMDVector ---------------------------------------------
    @_transparent
    public init( ) {
      self._value = Builtin.zeroInitializer()
    }

    public subscript(index: Int) -> ${Element} {
      @_transparent
      get {
        _precondition(index >= 0 && index < ${count})
        return ${Element}(Builtin.extractelement_${LLVM}_Int32(
          _value, Int32(index)._value
        ))
      }
      @_transparent
      set {
        _precondition(index >= 0 && index < ${count})
        _value = Builtin.insertelement_${LLVM}_Int${bits}_Int32(
          _value, newValue._value, Int32(index)._value
        )
      }
    }

    public typealias Mask = SIMD.Mask${bits}.Vector${count}

%   sext = 'Builtin.sext_Vec' + str(llvmN) + 'xInt1_' + LLVM
    @_transparent
    public static func .==(lhs: ${Self}, rhs: ${Self}) -> Mask {
      return Mask(Int${bits}.Vector${count}(${sext}(
        Builtin.cmp_eq_${LLVM}(lhs._value, rhs._value))))
    }

    // Conformance to SIMDVector${count} -------------------------------------
%   if count >= 4:
    public typealias HalfVector = Vector${count/2}
%   end

%   Index = 'Int' + str(bits) + '.' + Self
    @inlinable
    public init<D>(gathering source: D, at index: ${Index})
    where D : SIMDVector, D.Element == Element {
      self.init()
      for i in 0 ..< count {
        if index[i] >= 0 && index[i] < source.count {
          self[i] = source[Int(index[i])]
        }
      }
    }

    // Conformance to SIMDIntegerVector --------------------------------------
    @inlinable
    public init(bitMaskFrom mask: Mask) {
      self._value = mask._value._value
    }

    // - Functions
    @_transparent
    public var leadingZeroBitCount: ${Self} {
      return ${Self}(Builtin.int_ctlz_${LLVM}(self._value, false._value))
    }

    @_transparent
    public var trailingZeroBitCount: ${Self} {
      return ${Self}(Builtin.int_cttz_${LLVM}(self._value, false._value))
    }

    @_transparent
    public var nonzeroBitCount: ${Self} {
      return ${Self}(Builtin.int_ctpop_${LLVM}(self._value))
    }

    @_transparent
    public var elementBytesSwapped: ${Self} {
%   if bits == 8:
      return self
%   else:
      var result = ${Self}()
      for i in 0 ..< count {
        result[i] = Element(Builtin.int_bswap_Int${bits}(self[i]._value))
      }
      return result
%   end
    }

    // - Bitwise operators
%   for (op, inst) in [('&','and'), ('|','or'), ('^','xor')]:
    @_transparent
    public static func .${op}(lhs: ${Self}, rhs: ${Self}) -> ${Self} {
      return ${Self}(Builtin.${inst}_${LLVM}(lhs._value, rhs._value))
    }

%   end

%   prefix = 's' if signed else 'u'
%   for (op, inst) in [('<','lt'), ('<=','le'), ('>','gt'), ('>=','ge')]:
    @_transparent
    public static func .${op}(lhs: ${Self}, rhs: ${Self}) -> Mask {
      return Mask(Int${bits}.Vector${count}(${sext}(
        Builtin.cmp_${prefix}${inst}_${LLVM}(lhs._value, rhs._value)
      )))
    }

%   end

    @_transparent
    public static func .&>>(lhs: ${Self}, rhs: ${Self}) -> ${Self} {
      let masked = rhs .& ${Self}(repeating: ${bits-1})
%   if signed:
      return ${Self}(Builtin.ashr_${LLVM}(lhs._value, masked._value))
%   else:
      return ${Self}(Builtin.lshr_${LLVM}(lhs._value, masked._value))
%   end
    }

    @_transparent
    public static func .&<<(lhs: ${Self}, rhs: ${Self}) -> ${Self} {
      let masked = rhs .& ${Self}(repeating: ${bits-1})
      return ${Self}(Builtin.shl_${LLVM}(lhs._value, masked._value))
    }

    // MARK: Arithmetic operators
%   for (op, inst) in [('&+','add'), ('&-','sub'), ('&*','mul')]:
    @_transparent
    public static func .${op}(lhs: ${Self}, rhs: ${Self}) -> ${Self} {
      return ${Self}(Builtin.${inst}_${LLVM}(lhs._value, rhs._value))
    }

%   end
    @_transparent
    public static func ./(lhs: ${Self}, rhs: ${Self}) -> ${Self} {
      _precondition(all(rhs .!= 0), "Division by zero.")
%   if count == 3:
%   # special handling for the 3-element case: insert a 1 in the unused
%   # fourth component, to avoid dividing by zero since that would invoke
%   # UB at the LLVM IR level.
      let rhsValue = Builtin.insertelement_${LLVM}_Int${bits}_Int32(
        rhs._value, Int${bits}(1)._value, Int32(3)._value
      )
%   else:
      let rhsValue = rhs._value
%   end
%   if signed:
      _precondition(!any((lhs .== .min) .& (rhs .== -1)),
                    "Division results in an overflow.")
      return ${Self}(Builtin.sdiv_${LLVM}(lhs._value, rhsValue))
%   else:
      return ${Self}(Builtin.udiv_${LLVM}(lhs._value, rhsValue))
%   end
    }

    @_transparent
    public static func .%(lhs: ${Self}, rhs: ${Self}) -> ${Self} {
      _precondition(all(rhs .!= 0), "Division by zero in remainder operation.")
%   if count == 3:
%   # special handling for the 3-element case: insert a 1 in the unused
%   # fourth component, to avoid dividing by zero since that would invoke
%   # UB at the LLVM IR level.
      let rhsValue = Builtin.insertelement_${LLVM}_Int${bits}_Int32(
        rhs._value, Int${bits}(1)._value, Int32(3)._value
      )
%   else:
      let rhsValue = rhs._value
%   end
%   if signed:
      _precondition(!any((lhs .== .min) .& (rhs .== -1)),
                    "Division results in an overflow in remainder operation.")
      return ${Self}(Builtin.srem_${LLVM}(lhs._value, rhsValue))
%   else:
      return ${Self}(Builtin.urem_${LLVM}(lhs._value, rhsValue))
%   end
    }

    // Operations not required by any protocol -------------------------------
    @inlinable
    public init<Other>(truncatingIfNeeded other: Other)
    where Other : SIMDVector${count} & SIMDIntegerVector {
      self.init()
      for i in 0 ..< count { self[i] = Element(truncatingIfNeeded: other[i]) }
    }

    @inlinable
    public init<Other>(clamping other: Other)
    where Other : SIMDVector${count} & SIMDIntegerVector {
      self.init(truncatingIfNeeded:
        clamp(other,
              Other(repeating: Other.Element(clamping: Element.min)),
              Other(repeating: Other.Element(clamping: Element.max))
        )
      )
    }

%   if bits in [32, 64]:
%    FloatElement = fltnames[bits]
    @_transparent
    public init(bitPattern other: ${FloatElement}.Vector${count}) {
      _value = Builtin.bitcast_Vec${llvmN}xFPIEEE${bits}_${LLVM}(other._value)
    }

%   end
    // TODO: we shouldn't need the concrete conversions that follow; we should
    // be able to vectorize the for-loop in the generic `truncatingIfNeeded`
    // init to a single vector sext, zext, nop, or trunc (or possibly one per
    // Swift-ABI legalized result vector). However, the optimizer can't yet do
    // this for all cases, which we should fix, but as a short-term workaround
    // we also have these concrete conversions.
%   for other_type in all_integer_types(word_bits):
%    other_bits = other_type.bits
%    other_signed = other_type.is_signed
%    Other = other_type.stdlib_name
%    if other_bits*count <= 512:
%     OtherLLVM = 'Vec' + str(llvmN) + 'x' + other_type.builtin_name
    @_transparent
    public init(truncatingIfNeeded other: ${Other}.Vector${count}) {
%     if other_bits >= bits:
      self.init(Builtin.truncOrBitCast_${OtherLLVM}_${LLVM}(other._value))
%     elif other_signed:
      self.init(Builtin.sext_${OtherLLVM}_${LLVM}(other._value))
%     else:
      self.init(Builtin.zext_${OtherLLVM}_${LLVM}(other._value))
%     end
    }

%    end
%   end
  }

% end
}

%end
