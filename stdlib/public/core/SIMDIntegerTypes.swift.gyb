%{
eltsizes = [8,16,32,64]
counts = [2,3,4,8,16,32,64]
}%

%for bits in eltsizes:
% for signed in [True, False]:
%  Element = ('' if signed else 'U') + 'Int' + str(bits)
public extension ${Element} {
%  for N in counts:
%   # In theory, LLVM should handle padding 3-element vectors out to 4-element
%   # for us. And it does, but we end up triggering asserts for some operations,
%   # so it ends up being simpler to pad at the Swift level instead.
%   llvmN = N if N != 3 else 4
%   if bits*llvmN <= 512:
%    LLVM = 'Vec' + str(llvmN) + 'xInt' + str(bits)
%    Self = 'Vector' + str(N)
  @_fixed_layout
  struct ${Self} : SIMDIntegerVector, SIMDVector${N} {

    public var _value: Builtin.${LLVM}

    @_transparent
    public init(_ _value: Builtin.${LLVM}) {
      self._value = _value
    }

    // Conformance to SIMDVector ---------------------------------------------
    @_transparent
    public init( ) {
      self._value = Builtin.zeroInitializer()
    }

    public subscript(index: Int) -> ${Element} {
      @_transparent
      get {
        _precondition(index >= 0 && index < ${N})
        return ${Element}(Builtin.extractelement_${LLVM}_Int32(
          _value, Int32(index)._value
        ))
      }
      @_transparent
      set {
        _precondition(index >= 0 && index < ${N})
        _value = Builtin.insertelement_${LLVM}_Int${bits}_Int32(
          _value, newValue._value, Int32(index)._value
        )
      }
    }

    public typealias Predicate = SIMDPredicate${bits}x${N}

%    sext = 'Builtin.sext_Vec' + str(llvmN) + 'xInt1_' + LLVM
    @_transparent
    public static func ==(lhs: ${Self}, rhs: ${Self}) -> Predicate {
      return Predicate(Int${bits}.Vector${N}(${sext}(
        Builtin.cmp_eq_${LLVM}(lhs._value, rhs._value))))
    }

    // Conformance to SIMDVector${N} -----------------------------------------
%    if N >= 4:
    public typealias HalfVector = Vector${N/2}
%    end

    // Conformance to SIMDIntegerVector --------------------------------------
    @inlinable
    public init(bitMaskFrom predicate: Predicate) {
      self._value = predicate._value._value
    }

    // - Functions
    @_transparent
    public var leadingZeroBitCount: ${Self} {
      return ${Self}(Builtin.int_ctlz_${LLVM}(self._value, false._value))
    }

    @_transparent
    public var trailingZeroBitCount: ${Self} {
      return ${Self}(Builtin.int_cttz_${LLVM}(self._value, false._value))
    }

    @_transparent
    public var nonzeroBitCount: ${Self} {
      return ${Self}(Builtin.int_ctpop_${LLVM}(self._value))
    }

    @_transparent
    public var elementBytesSwapped: ${Self} {
%    if bits == 8:
      return self
%    else:
      var result = ${Self}()
      for i in indices {
        result[i] = Element(Builtin.int_bswap_Int${bits}(self[i]._value))
      }
      return result
%    end
    }

    // - Bitwise operators
%    for (op, inst) in [('&','and'), ('|','or'), ('^','xor')]:
    @_transparent
    public static func ${op}(lhs: ${Self}, rhs: ${Self}) -> ${Self} {
      return ${Self}(Builtin.${inst}_${LLVM}(lhs._value, rhs._value))
    }

%    end

%    prefix = 's' if signed else 'u'
%    for (op, inst) in [('<','lt'), ('<=','le'), ('>','gt'), ('>=','ge')]:
    @_transparent
    public static func ${op}(lhs: ${Self}, rhs: ${Self}) -> Predicate {
      return Predicate(Int${bits}.Vector${N}(${sext}(
        Builtin.cmp_${prefix}${inst}_${LLVM}(lhs._value, rhs._value)
      )))
    }

%    end

    @_transparent
    public static func &>>(lhs: ${Self}, rhs: ${Self}) -> ${Self} {
      let masked = rhs & ${Self}(repeating: ${bits-1})
%    if signed:
      return ${Self}(Builtin.ashr_${LLVM}(lhs._value, masked._value))
%    else:
      return ${Self}(Builtin.lshr_${LLVM}(lhs._value, masked._value))
%    end
    }

    @_transparent
    public static func &<<(lhs: ${Self}, rhs: ${Self}) -> ${Self} {
      let masked = rhs & ${Self}(repeating: ${bits-1})
      return ${Self}(Builtin.shl_${LLVM}(lhs._value, masked._value))
    }

    // MARK: Arithmetic operators
%    for (op, inst) in [('&+','add'), ('&-','sub'), ('&*','mul')]:
    @_transparent
    public static func ${op}(lhs: ${Self}, rhs: ${Self}) -> ${Self} {
      return ${Self}(Builtin.${inst}_${LLVM}(lhs._value, rhs._value))
    }

%    end
    @_transparent
    public static func /(lhs: ${Self}, rhs: ${Self}) -> ${Self} {
      _precondition(all(rhs != 0), "Division by zero.")
%    if N == 3:
%     # special handling for the 3-element case: insert a 1 in the unused
%     # fourth component, to avoid dividing by zero since that would invoke
%     # UB at the LLVM IR level.
      let rhsValue = Builtin.insertelement_${LLVM}_Int${bits}_Int32(
        rhs._value, Int${bits}(1)._value, Int32(3)._value
      )
%    else:
      let rhsValue = rhs._value
%    end
%    if signed:
      _precondition(!any((lhs == .min) & (rhs == -1)),
                    "Division results in an overflow.")
      return ${Self}(Builtin.sdiv_${LLVM}(lhs._value, rhsValue))
%    else:
      return ${Self}(Builtin.udiv_${LLVM}(lhs._value, rhsValue))
%    end
    }

    @_transparent
    public static func %(lhs: ${Self}, rhs: ${Self}) -> ${Self} {
      _precondition(all(rhs != 0), "Division by zero in remainder operation.")
%    if N == 3:
%     # special handling for the 3-element case: insert a 1 in the unused
%     # fourth component, to avoid dividing by zero since that would invoke
%     # UB at the LLVM IR level.
      let rhsValue = Builtin.insertelement_${LLVM}_Int${bits}_Int32(
        rhs._value, Int${bits}(1)._value, Int32(3)._value
      )
%    else:
      let rhsValue = rhs._value
%    end
%    if signed:
      _precondition(!any((lhs == .min) & (rhs == -1)),
                    "Division results in an overflow in remainder operation.")
      return ${Self}(Builtin.srem_${LLVM}(lhs._value, rhsValue))
%    else:
      return ${Self}(Builtin.urem_${LLVM}(lhs._value, rhsValue))
%    end
    }

    // Operations not required by any protocol -------------------------------
    @inlinable
    public init<Other>(truncatingIfNeeded other: Other)
    where Other : SIMDVector${N} & SIMDIntegerVector {
      self.init()
      for i in indices { self[i] = Element(truncatingIfNeeded: other[i]) }
    }

    @inlinable
    public init<Other>(clamping other: Other)
    where Other : SIMDVector${N} & SIMDIntegerVector {
      self.init(truncatingIfNeeded:
        clamp(other,
              Other(repeating: Other.Element(clamping: Element.min)),
              Other(repeating: Other.Element(clamping: Element.max))
        )
      )
    }

    // TODO: we shouldn't need the concrete conversions that follow; we should
    // be able to vectorize the for-loop in the generic `truncatingIfNeeded`
    // init to a single vector sext, zext, nop, or trunc (or possibly one per
    // Swift-ABI legalized result vector). However, the optimizer can't yet do
    // this for all cases, which we should fix, but as a short-term workaround
    // we also have these concrete conversions.
%    for otherBits in eltsizes:
%     if otherBits*llvmN <= 512:
%      for otherSigned in [True,False]:
%       OtherElement = ('' if otherSigned else 'U') + 'Int' + str(otherBits)
%       Other = OtherElement + '.Vector' + str(N)
%       OtherLLVM = 'Vec' + str(llvmN) + 'xInt' + str(otherBits)
    @_transparent
    public init(truncatingIfNeeded other: ${Other}) {
%       if otherBits > bits:
      self.init(Builtin.trunc_${OtherLLVM}_${LLVM}(other._value))
%       elif otherBits == bits:
      self.init(other._value)
%       elif otherSigned:
      self.init(Builtin.sext_${OtherLLVM}_${LLVM}(other._value))
%       else:
      self.init(Builtin.zext_${OtherLLVM}_${LLVM}(other._value))
%       end
    }

%      end
%     end
%    end
  }

%   end
%  end
}

% end
%end
