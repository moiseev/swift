public enum SIMD {
%{
from SwiftIntTypes import _all_integer_type_bitwidths
from SwiftVectorTypes import all_vector_counts
}%
%for bits in _all_integer_type_bitwidths:
  public enum Mask${bits} {
% for N in all_vector_counts:
%  if bits*N <= 512:
%   Self = 'Vector' + str(N)
%   Value = 'Int' + str(bits) + '.Vector' + str(N)
    @_fixed_layout
    public struct ${Self} : SIMDMask, SIMDVector${N} {

      public var _value: ${Value}

      // SIMDVector conformance ----------------------------------------------
      public typealias Mask = ${Self}

      @_transparent
      public init( ) {
        _value = ${Value}( )
      }

      @_transparent
      public init(_ _value: ${Value}) {
        self._value = _value
      }

      public subscript(index: Int) -> Bool {
        @_transparent
        get {
          return _value[index] < 0
        }
        @_transparent
        set {
          _value[index] = newValue ? -1 : 0
        }
      }

      @_transparent
      public static func .==(lhs: ${Self}, rhs: ${Self}) -> ${Self} {
        return lhs._value .== rhs._value
      }

      // SIMDVector${N} conformance ------------------------------------------
%   if N >= 4:
      public typealias HalfVector = Vector${N/2}

      //  The defaulted implementations of these properties from SIMDVector${N}
      //  work, but are inefficient because the select and shift on subscript
      //  get/set prevents the optimizer from fusing the extracts/inserts into
      //  a single shufflevector operation. Instead, map these into operations
      //  on the corresponding integer vector type.
%    for half in ['low','high','even','odd']:
      public var ${half}Half: HalfVector {
        @_transparent
        get {
          return HalfVector(_value.${half}Half)
        }
        @_transparent
        set {
          _value.${half}Half = newValue._value
        }
      }

%    end
%   end

%   Index = 'Int' + str(bits) + '.Vector' + str(N)
      @inlinable
      public init<D>(gathering source: D, at index: ${Index})
      where D : SIMDVector, D.Element == Element {
        self.init()
        for i in 0 ..< count {
          if index[i] >= 0 && index[i] < source.count {
            self[i] = source[Int(index[i])]
          }
        }
      }

      // SIMDMaskVector conformance -----------------------------------------
%   for op in ['&','|','^']:
      @_transparent
      public static func .${op}(lhs: ${Self}, rhs: ${Self}) -> ${Self} {
        return ${Self}(lhs._value .${op} rhs._value)
      }

%   end

      // TODO: replace with call to header inline C func specialized on
      // architecture once we have importer support.
      @inlinable
      public func _all() -> Bool {
        var result = true
        for i in 0 ..< count { result = result && self[i] }
        return result
      }

      // TODO: replace with call to header inline C func specialized on
      // architecture once we have importer support.
      @inlinable
      public func _any() -> Bool {
        var result = false
        for i in 0 ..< count { result = result || self[i] }
        return result
      }

      // Operations not required for protocol conformance --------------------
      @inlinable
      public init<Other>(_ other: Other) where Other : SIMDVector${N} & SIMDMask {
        self.init()
        for i in 0 ..< count { self[i] = other[i] }
      }

      // TODO: we shouldn't need the concrete conversions that follow; we
      // should be able to vectorize the for-loop in the generic init above,
      // but it doesn't always happen in practice, so we have this workaround.
%   for otherBits in [8,16,32,64]:
%    if otherBits*N <= 512 and otherBits != bits:
      @inlinable
      public init(_ other: Mask${otherBits}.Vector${N}) {
        _value = Int${bits}.Vector${N}(truncatingIfNeeded: other._value)
      }

%    end
%   end
    }

%  end
% end
  }
%end
}
