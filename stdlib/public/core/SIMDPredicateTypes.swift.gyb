%for bits in [8,16,32,64]:
% for N in [2,3,4,8,16,32,64]:
%  if bits*N <= 512:
%   Self = 'SIMDPredicate' + str(bits) + 'x' + str(N)
%   Value = 'Int' + str(bits) + '.Vector' + str(N)
@_fixed_layout
public struct ${Self} : SIMDPredicate, SIMDVector${N} {

  public var _value: ${Value}

  // SIMDVector conformance --------------------------------------------------
  public typealias Predicate = ${Self}

  @_transparent
  public init( ) {
    _value = ${Value}( )
  }

  @_transparent
  public init(_ _value: ${Value}) {
    self._value = _value
  }

  public subscript(index: Int) -> Bool {
    @_transparent
    get {
      return _value[index] < 0
    }
    @_transparent
    set {
      _value[index] = newValue ? -1 : 0
    }
  }

  @_transparent
  public static func ==(lhs: ${Self}, rhs: ${Self}) -> ${Self} {
    return lhs._value == rhs._value
  }

  // SIMDVector${N} conformance ----------------------------------------------
%   if N >= 4:
  public typealias HalfVector = SIMDPredicate${bits}x${N/2}

  //  The defaulted implementations of these properties from SIMDVector${N}
  //  work, but are inefficient because the select and shift on subscript
  //  get/set prevents the optimizer from fusing the extracts/inserts into
  //  a single shufflevector operation. Instead, map these into operations
  //  on the corresponding integer vector type.
%    for half in ['low','high','even','odd']:
  public var ${half}Half: HalfVector {
    @_transparent
    get {
      return HalfVector(_value.${half}Half)
    }
    @_transparent
    set {
      _value.${half}Half = newValue._value
    }
  }

%    end
%   end

%   Index = 'Int' + str(bits) + '.Vector' + str(N)
    @inlinable
    public init<D>(gathering source: D, at index: ${Index})
    where D : SIMDVector, D.Element == Element {
      self.init()
      for i in indices {
        if index[i] >= 0 && index[i] < source.count {
          self[i] = source[Int(index[i])]
        }
      }
    }

  // SIMDPredicateVector conformance -----------------------------------------
%   for op in ['&','|','^']:
  @_transparent
  public static func ${op}(lhs: ${Self}, rhs: ${Self}) -> ${Self} {
    return ${Self}(lhs._value ${op} rhs._value)
  }

%   end

  // Operations not required for protocol conformance ------------------------
  @inlinable
  public init<Other>(_ other: Other) where Other : SIMDVector${N} & SIMDPredicate {
    self.init()
    for i in indices { self[i] = other[i] }
  }

  // TODO: we shouldn't need the concrete conversions that follow; we should
  // be able to vectorize the for-loop in the generic init above, but it doesn't
  // always happen in practice, so we have this as a short-term workaround.
%   for otherBits in [8,16,32,64]:
%    if otherBits*N <= 512 and otherBits != bits:
  @inlinable
  public init(_ other: SIMDPredicate${otherBits}x${N}) {
    _value = Int${bits}.Vector${N}(truncatingIfNeeded: other._value)
  }

%    end
%   end
}

%  end
% end
%end
