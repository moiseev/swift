/*
%for bits in [8,16,32,64]:
% for N in [2,3,4,8,16,32,64]:
%  llvmN = N if N != 3 else 4
%  if bits*N <= 512:
%   LLVM = 'Vec' + str(llvmN) + 'xInt' + str(bits)
%   Self = 'SIMDPredicate' + str(bits) + 'x' + str(N)
@_fixed_layout
public struct ${Self} : SIMDPredicate, SIMDVector${N} {

  public var _value: Builtin.${LLVM}

  @_transparent
  public init( ) {
    self._value = Builtin.zeroInitializer()
  }

  @_transparent
  public init(_ _value: Builtin.${LLVM}) {
    self._value = _value
  }

  public subscript(index: Int) -> Bool {
    @_transparent
    get {
      _precondition(index >= 0 && index < ${N})
      return Int${bits}(Builtin.extractelement_${LLVM}_Int32(
        _value, Int32(index)._value
      )) < 0
    }
    @_transparent
    set {
      _precondition(index >= 0 && index < ${N})
      let newInt: Int${bits} = newValue ? -1 : 0
      _value = Builtin.insertelement_${LLVM}_Int${bits}_Int32(
        _value, newInt._value, Int32(index)._value
      )
    }
  }

  // MARK: Comparison operators
  public typealias Predicate = ${Self}

%   sextI1 = 'Builtin.sext_Vec' + str(llvmN) + 'xInt1_' + LLVM
%   for (op,inst) in [('==','eq'), ('!=','ne')]:
  @_transparent
  public static func ${op}(lhs: ${Self}, rhs: ${Self}) -> ${Self} {
    return ${Self}(${sextI1}(Builtin.cmp_${inst}_${LLVM}(lhs._value, rhs._value)))
  }

%   end
  // MARK: Logical operators
%   for (op,inst) in [('&&','and'), ('||','or')]:
  @_transparent
  public static func ${op}(lhs: ${Self}, rhs: ${Self}) -> ${Self} {
    return ${Self}(Builtin.${inst}_${LLVM}(lhs._value, rhs._value))
  }

%   end
%   if N >= 4:
  public typealias HalfVector = SIMDPredicate${bits}x${N/2}

  //  The defaulted implementations of these properties from SIMDVector${N}
  //  work, but are inefficient because the select and shift on subscript
  //  get/set prevents the optimizer from fusing the extracts/inserts into
  //  a single shufflevector operation. Instead, map these into operations
  //  on the corresponding integer vector type.
%    for half in ['low','high','even','odd']:
  public var ${half}Half: HalfVector {

    @_transparent
    get {
      return HalfVector(Int${bits}.Vector${N}(_value).${half}Half._value)
    }

    @_transparent
    set {
      var intVec = Int${bits}.Vector${N}(_value)
      intVec.${half}Half = Int${bits}.Vector${N/2}(newValue._value)
      _value = intVec._value
    }
  }

%    end
%   end
}
%  end
% end
%end
*/
